{"version":3,"file":"websandbox.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;ACVA,oCAAoC,+CAA+C,+BAA+B,mCAAmC,4EAA4E,mCAAmC,6CAA6C,iDAAiD,4IAA4I,0BAA0B,6JAA6J,oBAAoB,sEAAsE,GAAG,2BAA2B,mCAAmC,6BAA6B,8BAA8B,mDAAmD,uDAAuD,4BAA4B,gHAAgH,yCAAyC,kEAAkE,0DAA0D,WAAW,EAAE,sEAAsE,OAAO,iNAAiN,8BAA8B,kBAAkB,sBAAsB,eAAe,mFAAmF,qBAAqB,WAAW,4CAA4C,uEAAuE,WAAW,gDAAgD,2OAA2O,WAAW,sDAAsD,iDAAiD,kDAAkD,WAAW,wDAAwD,qPAAqP,WAAW,OAAO,0CAA0C,4CAA4C,OAAO,iLAAiL,iBAAiB,2BAA2B,2FAA2F,sGAAsG,OAAO,wBAAwB,mDAAmD,gEAAgE,2CAA2C,qIAAqI,EAAE,WAAW,kCAAkC,OAAO,8BAA8B,oCAAoC,OAAO,6GAA6G,mBAAmB,iDAAiD,qEAAqE,OAAO,8IAA8I,YAAY,2DAA2D,iDAAiD,gDAAgD,YAAY,oBAAoB,WAAW,2EAA2E,OAAO,oIAAoI,UAAU,4FAA4F,+BAA+B,gEAAgE,YAAY,OAAO,0LAA0L,mDAAmD,gEAAgE,2CAA2C,2JAA2J,EAAE,WAAW,EAAE,OAAO,sHAAsH,EAAE,+DAA+D,mDAAmD,gEAAgE,2CAA2C,mKAAmK,EAAE,WAAW,EAAE,OAAO,4MAA4M,wCAAwC,gKAAgK,uCAAuC,6BAA6B,eAAe,IAAI,EAAE,WAAW,iDAAiD,gHAAgH,OAAO,eAAe,uBAAuB,WAAW,uBAAuB,4EAA4E,iFAAiF,8DAA8D,2BAA2B,eAAe,WAAW,OAAO,wJAAwJ,uDAAuD,iCAAiC,mCAAmC,oBAAoB,OAAO,oOAAoO,wBAAwB,yDAAyD,WAAW,gBAAgB,yDAAyD,WAAW,oCAAoC,OAAO,GAAG,+DAA+D,KAAK,8GAA8G,qBAAqB,uGAAuG,2DAA2D,WAAW,EAAE,6CAA6C,sPAAsP,EAAE,uEAAuE,OAAO,+IAA+I,6DAA6D,qCAAqC,0EAA0E,OAAO,+BAA+B,6DAA6D,oCAAoC,0EAA0E,4EAA4E,OAAO,0BAA0B,2DAA2D,qCAAqC,yEAAyE,OAAO,6BAA6B,yDAAyD,qCAAqC,kCAAkC,wEAAwE,OAAO,GAAG,iCAAiC,uLAAuL,4IAA4I,cAAc,MAAM;;;;;;UCAv9S;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;;ACNO;AACA;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,8CAA8C,YAAY;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAe,UAAU,EAAC;;;;;;AC1MY;AACtC;AACiE;AAC1D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA,kCAAkC,UAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI,6BAA6B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0IAA0I,iBAAmB,CAAC;AAC9J;AACA;AACA,8CAA8C,sBAAsB;AACpE;AACA;AACA;AACA,0DAA0D,gBAAgB;AAC1E;AACA;AACA;AACA,+CAA+C,4BAA4B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,yCAAyC;AAClF,yBAAyB,uCAAuC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAe,UAAU,EAAC","sources":["webpack://Websandbox/webpack/universalModuleDefinition","webpack://Websandbox/./lib/frame.ts?9f69","webpack://Websandbox/webpack/bootstrap","webpack://Websandbox/webpack/runtime/compat get default export","webpack://Websandbox/webpack/runtime/define property getters","webpack://Websandbox/webpack/runtime/hasOwnProperty shorthand","webpack://Websandbox/webpack/runtime/make namespace object","webpack://Websandbox/./lib/connection.ts","webpack://Websandbox/./lib/websandbox.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Websandbox\"] = factory();\n\telse\n\t\troot[\"Websandbox\"] = factory();\n})(self, () => {\nreturn ","module.exports = \"/******/ (() => { // webpackBootstrap\\n/******/ \\t\\\"use strict\\\";\\nvar __webpack_exports__ = {};\\n\\n// UNUSED EXPORTS: default\\n\\n;// CONCATENATED MODULE: ./lib/connection.ts\\nconst TYPE_MESSAGE = 'message';\\nconst TYPE_RESPONSE = 'response';\\nconst TYPE_SET_INTERFACE = 'set-interface';\\nconst TYPE_SERVICE_MESSAGE = 'service-message';\\n// @ts-expect-error this is IE11 obsolete check. It is not typed\\nconst isIE11 = !!window.MSInputMethodContext && !!document.documentMode;\\nconst defaultOptions = {\\n    //Will not affect IE11 because there sandboxed iframe has not 'null' origin\\n    //but base URL of iframe's src\\n    allowedSenderOrigin: undefined\\n};\\nclass Connection {\\n    constructor(postMessage, registerOnMessageListener, options = {}) {\\n        this.remote = {};\\n        this.serviceMethods = {};\\n        this.localApi = {};\\n        this.callbacks = {};\\n        this._resolveRemoteMethodsPromise = null;\\n        this.options = Object.assign(Object.assign({}, defaultOptions), options);\\n        //Random number between 0 and 100000\\n        this.incrementalID = Math.floor(Math.random() * 100000);\\n        this.postMessage = postMessage;\\n        this.remoteMethodsWaitPromise = new Promise(resolve => {\\n            this._resolveRemoteMethodsPromise = resolve;\\n        });\\n        registerOnMessageListener((e) => this.onMessageListener(e));\\n    }\\n    /**\\n       * Listens to remote messages. Calls local method if it is called outside or call stored callback if it is response.\\n       * @param e - onMessage event\\n       */\\n    onMessageListener(e) {\\n        const data = e.data;\\n        const { allowedSenderOrigin } = this.options;\\n        if (allowedSenderOrigin && e.origin !== allowedSenderOrigin && !isIE11) {\\n            return;\\n        }\\n        if (data.type === TYPE_RESPONSE) {\\n            this.popCallback(data.callId, data.success, data.result);\\n        }\\n        else if (data.type === TYPE_MESSAGE) {\\n            this\\n                .callLocalApi(data.methodName, data.arguments)\\n                .then(res => this.responseOtherSide(data.callId, res))\\n                .catch(err => this.responseOtherSide(data.callId, err, false));\\n        }\\n        else if (data.type === TYPE_SET_INTERFACE) {\\n            this.setInterface(data.apiMethods);\\n            this.responseOtherSide(data.callId);\\n        }\\n        else if (data.type === TYPE_SERVICE_MESSAGE) {\\n            this\\n                .callLocalServiceMethod(data.methodName, data.arguments)\\n                .then(res => this.responseOtherSide(data.callId, res))\\n                .catch(err => this.responseOtherSide(data.callId, err, false));\\n        }\\n    }\\n    postMessageToOtherSide(dataToPost) {\\n        this.postMessage(dataToPost, '*');\\n    }\\n    /**\\n       * Sets remote interface methods\\n       * @param remote - hash with keys of remote API methods. Values is ignored\\n       */\\n    setInterface(remoteMethods) {\\n        var _a;\\n        this.remote = {};\\n        remoteMethods.forEach((key) => this.remote[key] = this.createMethodWrapper(key));\\n        (_a = this._resolveRemoteMethodsPromise) === null || _a === void 0 ? void 0 : _a.call(this);\\n    }\\n    setLocalApi(api) {\\n        return new Promise((resolve, reject) => {\\n            const id = this.registerCallback(resolve, reject);\\n            this.postMessageToOtherSide({\\n                callId: id,\\n                apiMethods: Object.keys(api),\\n                type: TYPE_SET_INTERFACE\\n            });\\n        }).then(() => this.localApi = api);\\n    }\\n    setServiceMethods(api) {\\n        this.serviceMethods = api;\\n    }\\n    /**\\n       * Calls local method\\n       * @param methodName\\n       * @param args\\n       * @returns {Promise.<*>|string}\\n       */\\n    callLocalApi(methodName, args) {\\n        return Promise.resolve(this.localApi[methodName](...args));\\n    }\\n    /**\\n       * Calls local method registered as \\\"service method\\\"\\n       * @param methodName\\n       * @param args\\n       * @returns {Promise.<*>}\\n       */\\n    callLocalServiceMethod(methodName, args) {\\n        if (!this.serviceMethods[methodName]) {\\n            throw new Error(`Serivce method ${methodName} is not registered`);\\n        }\\n        return Promise.resolve(this.serviceMethods[methodName](...args));\\n    }\\n    /**\\n       * Wraps remote method with callback storing code\\n       * @param methodName - method to wrap\\n       * @returns {Function} - function to call as remote API interface\\n       */\\n    createMethodWrapper(methodName) {\\n        return (...args) => {\\n            return this.callRemoteMethod(methodName, ...args);\\n        };\\n    }\\n    /**\\n       * Calls other side with arguments provided\\n       * @param id\\n       * @param methodName\\n       * @param args\\n       */\\n    callRemoteMethod(methodName, ...args) {\\n        return new Promise((resolve, reject) => {\\n            const id = this.registerCallback(resolve, reject);\\n            this.postMessageToOtherSide({\\n                callId: id,\\n                methodName: methodName,\\n                type: TYPE_MESSAGE,\\n                arguments: args\\n            });\\n        });\\n    }\\n    /**\\n       * Calls remote service method\\n       * @param methodName\\n       * @param args\\n       * @returns {*}\\n       */\\n    callRemoteServiceMethod(methodName, ...args) {\\n        return new Promise((resolve, reject) => {\\n            const id = this.registerCallback(resolve, reject);\\n            this.postMessageToOtherSide({\\n                callId: id,\\n                methodName: methodName,\\n                type: TYPE_SERVICE_MESSAGE,\\n                arguments: args\\n            });\\n        });\\n    }\\n    /**\\n       * Respond to remote call\\n       * @param id - remote call ID\\n       * @param result - result to pass to calling function\\n       */\\n    responseOtherSide(id, result, success = true) {\\n        if (result instanceof Error) {\\n            // Error could be non-serializable, so we copy properties manually\\n            result = [...Object.keys(result), 'message'].reduce((acc, it) => {\\n                acc[it] = result[it];\\n                return acc;\\n            }, {});\\n        }\\n        const doPost = () => this.postMessage({\\n            callId: id,\\n            type: TYPE_RESPONSE,\\n            success,\\n            result\\n        }, '*');\\n        try {\\n            doPost();\\n        }\\n        catch (err) {\\n            console.error('Failed to post response, recovering...', err); // eslint-disable-line no-console\\n            if (err instanceof DOMException) {\\n                result = JSON.parse(JSON.stringify(result));\\n                doPost();\\n            }\\n        }\\n    }\\n    /*\\n       * Stores callbacks to call later when remote call will be answered\\n       */\\n    registerCallback(successCallback, failureCallback) {\\n        const id = (++this.incrementalID).toString();\\n        this.callbacks[id] = { successCallback, failureCallback };\\n        return id;\\n    }\\n    /**\\n       * Calls and delete stored callback\\n       * @param id - call id\\n       * @param success - was call successful\\n       * @param result - result of remote call\\n       */\\n    popCallback(id, success, result) {\\n        if (success) {\\n            this.callbacks[id].successCallback(result);\\n        }\\n        else {\\n            this.callbacks[id].failureCallback(result);\\n        }\\n        delete this.callbacks[id];\\n    }\\n}\\n/* harmony default export */ const connection = (Connection);\\n\\n;// CONCATENATED MODULE: ./node_modules/ts-loader/index.js??ruleSet[1].rules[0]!./lib/frame.ts\\n\\nclass Frame {\\n    constructor() {\\n        this.connection = new connection(window.parent.postMessage.bind(window.parent), listener => {\\n            window.addEventListener('message', listener);\\n        });\\n        this.connection.setServiceMethods({\\n            runCode: (code) => this.runCode(code),\\n            importScript: (path) => this.importScript(path),\\n            injectStyle: (style) => this.injectStyle(style),\\n            importStyle: (path) => this.importStyle(path)\\n        });\\n        this.connection.callRemoteServiceMethod('iframeInitialized');\\n    }\\n    /**\\n       * Creates script tag with passed code and attaches it. Runs synchronous\\n       * @param code\\n       */\\n    runCode(code) {\\n        const scriptTag = document.createElement('script');\\n        scriptTag.innerHTML = code;\\n        document.getElementsByTagName('head')[0].appendChild(scriptTag);\\n    }\\n    importScript(scriptUrl) {\\n        const scriptTag = document.createElement('script');\\n        scriptTag.src = scriptUrl;\\n        document.getElementsByTagName('head')[0].appendChild(scriptTag);\\n        return new Promise(resolve => scriptTag.onload = () => resolve());\\n    }\\n    injectStyle(style) {\\n        const styleTag = document.createElement('style');\\n        styleTag.innerHTML = style;\\n        document.getElementsByTagName('head')[0].appendChild(styleTag);\\n    }\\n    importStyle(styleUrl) {\\n        const linkTag = document.createElement('link');\\n        linkTag.rel = 'stylesheet';\\n        linkTag.href = styleUrl;\\n        document.getElementsByTagName('head')[0].appendChild(linkTag);\\n    }\\n}\\nconst Websandbox = new Frame();\\n// @ts-expect-error we explicitly export library to global namespace because\\n// Webpack won't do it for us when this file is loaded via code-loader\\nwindow.Websandbox = Websandbox;\\n/* harmony default export */ const ts_loader_ruleSet_1_rules_0_lib_frame = ((/* unused pure expression or super */ null && (Websandbox)));\\n\\n/******/ })()\\n;\\n//# sourceMappingURL=compile-loader-file-name.js.map\"","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export const TYPE_MESSAGE = 'message';\nexport const TYPE_RESPONSE = 'response';\nexport const TYPE_SET_INTERFACE = 'set-interface';\nexport const TYPE_SERVICE_MESSAGE = 'service-message';\n// @ts-expect-error this is IE11 obsolete check. It is not typed\nconst isIE11 = !!window.MSInputMethodContext && !!document.documentMode;\nconst defaultOptions = {\n    //Will not affect IE11 because there sandboxed iframe has not 'null' origin\n    //but base URL of iframe's src\n    allowedSenderOrigin: undefined\n};\nclass Connection {\n    constructor(postMessage, registerOnMessageListener, options = {}) {\n        this.remote = {};\n        this.serviceMethods = {};\n        this.localApi = {};\n        this.callbacks = {};\n        this._resolveRemoteMethodsPromise = null;\n        this.options = Object.assign(Object.assign({}, defaultOptions), options);\n        //Random number between 0 and 100000\n        this.incrementalID = Math.floor(Math.random() * 100000);\n        this.postMessage = postMessage;\n        this.remoteMethodsWaitPromise = new Promise(resolve => {\n            this._resolveRemoteMethodsPromise = resolve;\n        });\n        registerOnMessageListener((e) => this.onMessageListener(e));\n    }\n    /**\n       * Listens to remote messages. Calls local method if it is called outside or call stored callback if it is response.\n       * @param e - onMessage event\n       */\n    onMessageListener(e) {\n        const data = e.data;\n        const { allowedSenderOrigin } = this.options;\n        if (allowedSenderOrigin && e.origin !== allowedSenderOrigin && !isIE11) {\n            return;\n        }\n        if (data.type === TYPE_RESPONSE) {\n            this.popCallback(data.callId, data.success, data.result);\n        }\n        else if (data.type === TYPE_MESSAGE) {\n            this\n                .callLocalApi(data.methodName, data.arguments)\n                .then(res => this.responseOtherSide(data.callId, res))\n                .catch(err => this.responseOtherSide(data.callId, err, false));\n        }\n        else if (data.type === TYPE_SET_INTERFACE) {\n            this.setInterface(data.apiMethods);\n            this.responseOtherSide(data.callId);\n        }\n        else if (data.type === TYPE_SERVICE_MESSAGE) {\n            this\n                .callLocalServiceMethod(data.methodName, data.arguments)\n                .then(res => this.responseOtherSide(data.callId, res))\n                .catch(err => this.responseOtherSide(data.callId, err, false));\n        }\n    }\n    postMessageToOtherSide(dataToPost) {\n        this.postMessage(dataToPost, '*');\n    }\n    /**\n       * Sets remote interface methods\n       * @param remote - hash with keys of remote API methods. Values is ignored\n       */\n    setInterface(remoteMethods) {\n        var _a;\n        this.remote = {};\n        remoteMethods.forEach((key) => this.remote[key] = this.createMethodWrapper(key));\n        (_a = this._resolveRemoteMethodsPromise) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n    setLocalApi(api) {\n        return new Promise((resolve, reject) => {\n            const id = this.registerCallback(resolve, reject);\n            this.postMessageToOtherSide({\n                callId: id,\n                apiMethods: Object.keys(api),\n                type: TYPE_SET_INTERFACE\n            });\n        }).then(() => this.localApi = api);\n    }\n    setServiceMethods(api) {\n        this.serviceMethods = api;\n    }\n    /**\n       * Calls local method\n       * @param methodName\n       * @param args\n       * @returns {Promise.<*>|string}\n       */\n    callLocalApi(methodName, args) {\n        return Promise.resolve(this.localApi[methodName](...args));\n    }\n    /**\n       * Calls local method registered as \"service method\"\n       * @param methodName\n       * @param args\n       * @returns {Promise.<*>}\n       */\n    callLocalServiceMethod(methodName, args) {\n        if (!this.serviceMethods[methodName]) {\n            throw new Error(`Serivce method ${methodName} is not registered`);\n        }\n        return Promise.resolve(this.serviceMethods[methodName](...args));\n    }\n    /**\n       * Wraps remote method with callback storing code\n       * @param methodName - method to wrap\n       * @returns {Function} - function to call as remote API interface\n       */\n    createMethodWrapper(methodName) {\n        return (...args) => {\n            return this.callRemoteMethod(methodName, ...args);\n        };\n    }\n    /**\n       * Calls other side with arguments provided\n       * @param id\n       * @param methodName\n       * @param args\n       */\n    callRemoteMethod(methodName, ...args) {\n        return new Promise((resolve, reject) => {\n            const id = this.registerCallback(resolve, reject);\n            this.postMessageToOtherSide({\n                callId: id,\n                methodName: methodName,\n                type: TYPE_MESSAGE,\n                arguments: args\n            });\n        });\n    }\n    /**\n       * Calls remote service method\n       * @param methodName\n       * @param args\n       * @returns {*}\n       */\n    callRemoteServiceMethod(methodName, ...args) {\n        return new Promise((resolve, reject) => {\n            const id = this.registerCallback(resolve, reject);\n            this.postMessageToOtherSide({\n                callId: id,\n                methodName: methodName,\n                type: TYPE_SERVICE_MESSAGE,\n                arguments: args\n            });\n        });\n    }\n    /**\n       * Respond to remote call\n       * @param id - remote call ID\n       * @param result - result to pass to calling function\n       */\n    responseOtherSide(id, result, success = true) {\n        if (result instanceof Error) {\n            // Error could be non-serializable, so we copy properties manually\n            result = [...Object.keys(result), 'message'].reduce((acc, it) => {\n                acc[it] = result[it];\n                return acc;\n            }, {});\n        }\n        const doPost = () => this.postMessage({\n            callId: id,\n            type: TYPE_RESPONSE,\n            success,\n            result\n        }, '*');\n        try {\n            doPost();\n        }\n        catch (err) {\n            console.error('Failed to post response, recovering...', err); // eslint-disable-line no-console\n            if (err instanceof DOMException) {\n                result = JSON.parse(JSON.stringify(result));\n                doPost();\n            }\n        }\n    }\n    /*\n       * Stores callbacks to call later when remote call will be answered\n       */\n    registerCallback(successCallback, failureCallback) {\n        const id = (++this.incrementalID).toString();\n        this.callbacks[id] = { successCallback, failureCallback };\n        return id;\n    }\n    /**\n       * Calls and delete stored callback\n       * @param id - call id\n       * @param success - was call successful\n       * @param result - result of remote call\n       */\n    popCallback(id, success, result) {\n        if (success) {\n            this.callbacks[id].successCallback(result);\n        }\n        else {\n            this.callbacks[id].failureCallback(result);\n        }\n        delete this.callbacks[id];\n    }\n}\nexport default Connection;\n","import Connection from './connection';\n// @ts-expect-error loader-based input\nimport CompiledFrameScript from 'compile-code-loader!./frame.ts';\nexport const BaseOptions = {\n    frameContainer: 'body',\n    frameClassName: 'websandbox__frame',\n    frameSrc: null,\n    frameContent: `\n<!DOCTYPE html>\n<html>\n<head><meta charset=\"UTF-8\"></head>\n<body></body>\n</html>\n  `,\n    codeToRunBeforeInit: null,\n    initialStyles: null,\n    baseUrl: null,\n    allowPointerLock: false,\n    allowFullScreen: false,\n    sandboxAdditionalAttributes: ''\n};\nclass Websandbox {\n    /**\n     * Creates sandbox instancea\n     * @param localApi Api of this side. Will be available for sandboxed code as remoteApi\n     * @param options Options of created sandbox\n     */\n    static create(localApi, options = {}) {\n        return new Websandbox(localApi, options);\n    }\n    /**\n     * {Constructor}\n     * @param localApi\n     * @param options\n     */\n    constructor(localApi, options) {\n        this.connection = null;\n        this.removeMessageListener = () => { };\n        this.validateOptions(options);\n        this.options = Object.assign(Object.assign({}, BaseOptions), options);\n        this.iframe = this.createIframe();\n        this.promise = new Promise(resolve => {\n            this.connection = new Connection(this.iframe.contentWindow.postMessage.bind(this.iframe.contentWindow), listener => {\n                const sourceCheckListener = (event) => {\n                    if (event.source !== this.iframe.contentWindow) {\n                        return;\n                    }\n                    return listener(event);\n                };\n                window.addEventListener('message', sourceCheckListener);\n                this.removeMessageListener = () => window.removeEventListener('message', sourceCheckListener);\n            }, { allowedSenderOrigin: 'null' });\n            this.connection.setServiceMethods({\n                iframeInitialized: () => {\n                    return this.connection\n                        .setLocalApi(localApi)\n                        .then(() => resolve(this));\n                }\n            });\n        });\n    }\n    validateOptions(options) {\n        var _a;\n        if (options.frameSrc && (options.frameContent || options.initialStyles || options.baseUrl || options.codeToRunBeforeInit)) {\n            throw new Error('You can not set both \"frameSrc\" and any of frameContent,initialStyles,baseUrl,codeToRunBeforeInit options');\n        }\n        if ('frameContent' in options && !((_a = options.frameContent) === null || _a === void 0 ? void 0 : _a.includes('<head>'))) {\n            throw new Error('Websandbox: iFrame content must have \"<head>\" tag.');\n        }\n    }\n    _prepareFrameContent(options) {\n        var _a, _b;\n        let frameContent = (_b = (_a = options.frameContent) === null || _a === void 0 ? void 0 : _a.replace('<head>', `<head>\\n<script>${CompiledFrameScript}</script>`)) !== null && _b !== void 0 ? _b : '';\n        if (options.initialStyles) {\n            frameContent = frameContent\n                .replace('</head>', `<style>${options.initialStyles}</style>\\n</head>`);\n        }\n        if (options.baseUrl) {\n            frameContent = frameContent\n                .replace('<head>', `<head>\\n<base href=\"${options.baseUrl}\"/>`);\n        }\n        if (options.codeToRunBeforeInit) {\n            frameContent = frameContent\n                .replace('</head>', `<script>${options.codeToRunBeforeInit}</script>\\n</head>`);\n        }\n        return frameContent;\n    }\n    createIframe() {\n        var _a;\n        const containerSelector = this.options.frameContainer;\n        const container = typeof containerSelector === 'string'\n            ? document.querySelector(containerSelector)\n            : containerSelector;\n        if (!container) {\n            throw new Error('Websandbox: Cannot find container for sandbox ' + container);\n        }\n        const frame = document.createElement('iframe');\n        // @ts-expect-error typings error\n        frame.sandbox = `allow-scripts ${this.options.sandboxAdditionalAttributes}`;\n        frame.allow = `${this.options.allowAdditionalAttributes}`;\n        frame.className = (_a = this.options.frameClassName) !== null && _a !== void 0 ? _a : '';\n        if (this.options.allowFullScreen) {\n            frame.allowFullscreen = true;\n        }\n        if (this.options.frameSrc) {\n            frame.src = this.options.frameSrc;\n            container.appendChild(frame);\n            return frame;\n        }\n        frame.setAttribute('srcdoc', this._prepareFrameContent(this.options));\n        container.appendChild(frame);\n        return frame;\n    }\n    destroy() {\n        this.iframe.remove();\n        this.removeMessageListener();\n    }\n    _runCode(code) {\n        return this.connection.callRemoteServiceMethod('runCode', code);\n    }\n    _runFunction(fn) {\n        return this._runCode(`(${fn.toString()})()`);\n    }\n    run(codeOrFunction) {\n        if (codeOrFunction.name) {\n            return this._runFunction(codeOrFunction);\n        }\n        return this._runCode(codeOrFunction);\n    }\n    importScript(path) {\n        return this.connection.callRemoteServiceMethod('importScript', path);\n    }\n    injectStyle(style) {\n        return this.connection.callRemoteServiceMethod('injectStyle', style);\n    }\n}\nexport default Websandbox;\n"],"names":[],"sourceRoot":""}