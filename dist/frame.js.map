{"version":3,"file":"frame.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;UCVA;UACA;;;;;WCDA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;ACNO;AACA;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,8CAA8C,YAAY;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAe,UAAU,EAAC;;;AC1MY;AACtC;AACA;AACA,8BAA8B,UAAU;AACxC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAe,UAAU,EAAC","sources":["webpack://Websandbox/webpack/universalModuleDefinition","webpack://Websandbox/webpack/bootstrap","webpack://Websandbox/webpack/runtime/define property getters","webpack://Websandbox/webpack/runtime/hasOwnProperty shorthand","webpack://Websandbox/webpack/runtime/make namespace object","webpack://Websandbox/./lib/connection.ts","webpack://Websandbox/./lib/frame.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Websandbox\"] = factory();\n\telse\n\t\troot[\"Websandbox\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export const TYPE_MESSAGE = 'message';\nexport const TYPE_RESPONSE = 'response';\nexport const TYPE_SET_INTERFACE = 'set-interface';\nexport const TYPE_SERVICE_MESSAGE = 'service-message';\n// @ts-expect-error this is IE11 obsolete check. It is not typed\nconst isIE11 = !!window.MSInputMethodContext && !!document.documentMode;\nconst defaultOptions = {\n    //Will not affect IE11 because there sandboxed iframe has not 'null' origin\n    //but base URL of iframe's src\n    allowedSenderOrigin: undefined\n};\nclass Connection {\n    constructor(postMessage, registerOnMessageListener, options = {}) {\n        this.remote = {};\n        this.serviceMethods = {};\n        this.localApi = {};\n        this.callbacks = {};\n        this._resolveRemoteMethodsPromise = null;\n        this.options = Object.assign(Object.assign({}, defaultOptions), options);\n        //Random number between 0 and 100000\n        this.incrementalID = Math.floor(Math.random() * 100000);\n        this.postMessage = postMessage;\n        this.remoteMethodsWaitPromise = new Promise(resolve => {\n            this._resolveRemoteMethodsPromise = resolve;\n        });\n        registerOnMessageListener((e) => this.onMessageListener(e));\n    }\n    /**\n       * Listens to remote messages. Calls local method if it is called outside or call stored callback if it is response.\n       * @param e - onMessage event\n       */\n    onMessageListener(e) {\n        const data = e.data;\n        const { allowedSenderOrigin } = this.options;\n        if (allowedSenderOrigin && e.origin !== allowedSenderOrigin && !isIE11) {\n            return;\n        }\n        if (data.type === TYPE_RESPONSE) {\n            this.popCallback(data.callId, data.success, data.result);\n        }\n        else if (data.type === TYPE_MESSAGE) {\n            this\n                .callLocalApi(data.methodName, data.arguments)\n                .then(res => this.responseOtherSide(data.callId, res))\n                .catch(err => this.responseOtherSide(data.callId, err, false));\n        }\n        else if (data.type === TYPE_SET_INTERFACE) {\n            this.setInterface(data.apiMethods);\n            this.responseOtherSide(data.callId);\n        }\n        else if (data.type === TYPE_SERVICE_MESSAGE) {\n            this\n                .callLocalServiceMethod(data.methodName, data.arguments)\n                .then(res => this.responseOtherSide(data.callId, res))\n                .catch(err => this.responseOtherSide(data.callId, err, false));\n        }\n    }\n    postMessageToOtherSide(dataToPost) {\n        this.postMessage(dataToPost, '*');\n    }\n    /**\n       * Sets remote interface methods\n       * @param remote - hash with keys of remote API methods. Values is ignored\n       */\n    setInterface(remoteMethods) {\n        var _a;\n        this.remote = {};\n        remoteMethods.forEach((key) => this.remote[key] = this.createMethodWrapper(key));\n        (_a = this._resolveRemoteMethodsPromise) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n    setLocalApi(api) {\n        return new Promise((resolve, reject) => {\n            const id = this.registerCallback(resolve, reject);\n            this.postMessageToOtherSide({\n                callId: id,\n                apiMethods: Object.keys(api),\n                type: TYPE_SET_INTERFACE\n            });\n        }).then(() => this.localApi = api);\n    }\n    setServiceMethods(api) {\n        this.serviceMethods = api;\n    }\n    /**\n       * Calls local method\n       * @param methodName\n       * @param args\n       * @returns {Promise.<*>|string}\n       */\n    callLocalApi(methodName, args) {\n        return Promise.resolve(this.localApi[methodName](...args));\n    }\n    /**\n       * Calls local method registered as \"service method\"\n       * @param methodName\n       * @param args\n       * @returns {Promise.<*>}\n       */\n    callLocalServiceMethod(methodName, args) {\n        if (!this.serviceMethods[methodName]) {\n            throw new Error(`Serivce method ${methodName} is not registered`);\n        }\n        return Promise.resolve(this.serviceMethods[methodName](...args));\n    }\n    /**\n       * Wraps remote method with callback storing code\n       * @param methodName - method to wrap\n       * @returns {Function} - function to call as remote API interface\n       */\n    createMethodWrapper(methodName) {\n        return (...args) => {\n            return this.callRemoteMethod(methodName, ...args);\n        };\n    }\n    /**\n       * Calls other side with arguments provided\n       * @param id\n       * @param methodName\n       * @param args\n       */\n    callRemoteMethod(methodName, ...args) {\n        return new Promise((resolve, reject) => {\n            const id = this.registerCallback(resolve, reject);\n            this.postMessageToOtherSide({\n                callId: id,\n                methodName: methodName,\n                type: TYPE_MESSAGE,\n                arguments: args\n            });\n        });\n    }\n    /**\n       * Calls remote service method\n       * @param methodName\n       * @param args\n       * @returns {*}\n       */\n    callRemoteServiceMethod(methodName, ...args) {\n        return new Promise((resolve, reject) => {\n            const id = this.registerCallback(resolve, reject);\n            this.postMessageToOtherSide({\n                callId: id,\n                methodName: methodName,\n                type: TYPE_SERVICE_MESSAGE,\n                arguments: args\n            });\n        });\n    }\n    /**\n       * Respond to remote call\n       * @param id - remote call ID\n       * @param result - result to pass to calling function\n       */\n    responseOtherSide(id, result, success = true) {\n        if (result instanceof Error) {\n            // Error could be non-serializable, so we copy properties manually\n            result = [...Object.keys(result), 'message'].reduce((acc, it) => {\n                acc[it] = result[it];\n                return acc;\n            }, {});\n        }\n        const doPost = () => this.postMessage({\n            callId: id,\n            type: TYPE_RESPONSE,\n            success,\n            result\n        }, '*');\n        try {\n            doPost();\n        }\n        catch (err) {\n            console.error('Failed to post response, recovering...', err); // eslint-disable-line no-console\n            if (err instanceof DOMException) {\n                result = JSON.parse(JSON.stringify(result));\n                doPost();\n            }\n        }\n    }\n    /*\n       * Stores callbacks to call later when remote call will be answered\n       */\n    registerCallback(successCallback, failureCallback) {\n        const id = (++this.incrementalID).toString();\n        this.callbacks[id] = { successCallback, failureCallback };\n        return id;\n    }\n    /**\n       * Calls and delete stored callback\n       * @param id - call id\n       * @param success - was call successful\n       * @param result - result of remote call\n       */\n    popCallback(id, success, result) {\n        if (success) {\n            this.callbacks[id].successCallback(result);\n        }\n        else {\n            this.callbacks[id].failureCallback(result);\n        }\n        delete this.callbacks[id];\n    }\n}\nexport default Connection;\n","import Connection from './connection';\nclass Frame {\n    constructor() {\n        this.connection = new Connection(window.parent.postMessage.bind(window.parent), listener => {\n            window.addEventListener('message', listener);\n        });\n        this.connection.setServiceMethods({\n            runCode: (code) => this.runCode(code),\n            importScript: (path) => this.importScript(path),\n            injectStyle: (style) => this.injectStyle(style),\n            importStyle: (path) => this.importStyle(path)\n        });\n        this.connection.callRemoteServiceMethod('iframeInitialized');\n    }\n    /**\n       * Creates script tag with passed code and attaches it. Runs synchronous\n       * @param code\n       */\n    runCode(code) {\n        const scriptTag = document.createElement('script');\n        scriptTag.innerHTML = code;\n        document.getElementsByTagName('head')[0].appendChild(scriptTag);\n    }\n    importScript(scriptUrl) {\n        const scriptTag = document.createElement('script');\n        scriptTag.src = scriptUrl;\n        document.getElementsByTagName('head')[0].appendChild(scriptTag);\n        return new Promise(resolve => scriptTag.onload = () => resolve());\n    }\n    injectStyle(style) {\n        const styleTag = document.createElement('style');\n        styleTag.innerHTML = style;\n        document.getElementsByTagName('head')[0].appendChild(styleTag);\n    }\n    importStyle(styleUrl) {\n        const linkTag = document.createElement('link');\n        linkTag.rel = 'stylesheet';\n        linkTag.href = styleUrl;\n        document.getElementsByTagName('head')[0].appendChild(linkTag);\n    }\n}\nconst Websandbox = new Frame();\n// @ts-expect-error we explicitly export library to global namespace because\n// Webpack won't do it for us when this file is loaded via code-loader\nwindow.Websandbox = Websandbox;\nexport default Websandbox;\n"],"names":[],"sourceRoot":""}